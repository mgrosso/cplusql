// -*- C++ -*-
//
// $Id: ReadWriteServiceImpl.cpp,v 1.27 2004/08/03 21:20:41 sjackson Exp $

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


#include "ReadWriteServiceImpl.h"
#include "AppLog.h"
#include "DateUtils.h"
#include "Exclusion.h"
#include "keys.h"
#include "ptr.h"
#include "ptr_strdup.h"
#include "ReadWriteController.h"
#include "SharedServiceMain.h"
#include "ServiceInfo.h"

#include <string>
#include <sstream>


clusterio_ReadWriteServiceImpl::clusterio_ReadWriteServiceImpl(const Config &config) : cfg_(0), rwc_(0), isPendingShutdown_(false), fdUsageCheckTm_(0L), exceptionCnt_(0)
{
	init(&config);
}


clusterio_ReadWriteServiceImpl::~clusterio_ReadWriteServiceImpl(void)
{
	if (rwc_ != (ReadWriteController *) 0)
	{
		delete rwc_;
		rwc_ = (ReadWriteController *) 0;
	}

	if (cfg_ != (Config *) 0)
	{
		delete cfg_;
		cfg_ = (Config *) 0;
	}
}


void
clusterio_ReadWriteServiceImpl::init(const Config *config)
{
	MutexGuard guard(lock_);

	if (config != (const Config *) 0)
	{
		if (cfg_ != (Config *) 0)
		{
			delete cfg_;
		}
		cfg_ = new Config(*config);
	}

	if (rwc_ != (ReadWriteController *) 0)
	{
		delete rwc_;
	}

	rwc_ = new ReadWriteController(*cfg_);
	rwc_->init();
}


void
clusterio_ReadWriteServiceImpl::emitTime(const struct timeval &startT,
	const char *op, int line) throw ()
{
	double totalT = DateUtils::diffTime(startT);

	if (line == 0)
	{
		APPLOG_INFO("finaltime(%s): %8.4fs", op, totalT);
	}
	else
	{
		exceptionCnt_++;
		fdUsageCheckTm_ = 0L;
		APPLOG_INFO("finaltime(%s): %8.4fs error at %d", op, totalT, line);
	}
}


void
clusterio_ReadWriteServiceImpl::logClusterIOException(const char *op, const clusterio::ClusterIOException &cie) throw ()
{
	std::ostringstream oss;
	int sz = cie.exceptions.length();

	oss << op << " caught a clusterio::ClusterIOException(cnt=" << sz << ")";

	for (int i = 0; i < sz; i++)
	{
		clusterio::io_exception_struct ies = cie.exceptions[i];

		oss << i << ": ref=" << ies.serviceRef.url.in() << " type=" << ies.type <<
			" errno=" << ies.errno_short << " what=" << ies.what_string << " / ";
	}

	std::string s = oss.str();
	const char *p = s.c_str();

	APPLOG_ALARM(p);
}


void
clusterio_ReadWriteServiceImpl::verifyState()
	throw (Service::PendingShutdownException, Service::ServiceException)
{
	if (rwc_ == (ReadWriteController *) 0)
	{
		APPLOG_WARN("verifyState: no rwc");
		throw Service::ServiceException(0, "null ReadWriteController");
	}
	else if (isPendingShutdown_)
	{
		APPLOG_WARN("verifyState: pendingShutdown");
		throw Service::PendingShutdownException();
	}
	else
	{
#ifdef BETTER_CHECKING_FOR_NO_FDS_AVAILABLE
		time_t nowT = ::time((time_t *) 0);

		if ((fdUsageCheckTm_ == 0) || (nowT - fdUsageCheckTm_ >= 0))
		{
			MutexGuard guard(lock_);
			int sz = rwc_->getProcessInfo()->getCurrentFDUsage();

			APPLOG_DBG("process fdUsage=%d", sz);
			if (sz == -1)
			{
				int mx = rwc_->getCacheMaxSize();
				int cur = rwc_->getCacheCurrentSize();
				int nMx = min(mx, cur);
				double scaleDown = nMx * 0.9;

				nMx = (int) scaleDown;
				nMx = max(5, nMx);

				APPLOG_WARN("Failed to find FD; rwc max=%d, curr=%d, setting to %d",
					mx, cur, nMx);

				rwc_->setCacheMaxSize(nMx);
			}
			fdUsageCheckTm_ = nowT;
		}
#endif
	}
}


int
clusterio_ReadWriteServiceImpl::waitForZeroConnections(int maxWait)
{
	int retVal = 0;
	time_t startT = ::time((time_t *) 0);
	time_t nowT = startT;

	while (nowT - startT < maxWait)
	{
		if (rwc_ == (ReadWriteController *) 0)
		{
			break;
		}
		else
		{
			retVal = rwc_->getCurrentUserCount();
		}

		APPLOG_DBG("waitForZeroConnections=%d", retVal);

		if (retVal == 0)
		{
			break;
		}
		else
		{
			(void) ::sleep(1);
			nowT = ::time((time_t *) 0);
		}
	}

	return retVal;
}


void clusterio_ReadWriteServiceImpl::append (
    const clusterio::open_info & fd,
    const clusterio::blockseq & blocks,
    const clusterio::writer_id & writer,
    CORBA::ULong sequence_num
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , clusterio::ClusterIOException
    , Service::ServiceException
  ))
{
	const char *op = "append";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		verifyState();

		rwc_->append(fd, blocks, writer, sequence_num);
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}
}


clusterio::length_t clusterio_ReadWriteServiceImpl::undo_appends (
    const clusterio::open_info & fd,
    const clusterio::writer_id & writer,
    CORBA::ULong_out next_sequence_num
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , clusterio::ClusterIOException
    , Service::ServiceException
  ))
{
	clusterio::length_t retVal = 0;
	const char *op = "undo_appends";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);
	try {
		verifyState();

		retVal = rwc_->undo_appends(fd, writer, next_sequence_num);
		APPLOG_DBG("%s end %lld", op, retVal);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}

	return retVal;
}


clusterio::length_t clusterio_ReadWriteServiceImpl::read (
    const clusterio::open_info & fd,
    clusterio::length_t first_byte,
    clusterio::length_t size,
    clusterio::file_data_t_out data
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , clusterio::ClusterIOException
    , Service::ServiceException
  ))
{
	clusterio::length_t retVal;
	const char *op = "read";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		verifyState();

		retVal = rwc_->read(fd, first_byte, size, data);
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}

	return retVal;
}


::clusterio::file_handle_status_seq * clusterio_ReadWriteServiceImpl::stat (
    const clusterio::file_handle_seq & fdset,
    CORBA::Boolean checksums
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
	clusterio::file_handle_status_seq *retVal = 0;
	const char *op = "stat";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		verifyState();

		retVal = rwc_->stat(fdset, checksums);
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}

	return retVal;
}


void clusterio_ReadWriteServiceImpl::namespace_cp (
    const clusterio::file_handle & fd,
    const Service::ServiceRef & source,
    const clusterio::file_handle & sourcefd
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
	, clusterio::ClusterIOException
    , Service::ServiceException
  ))
{
	const char *op = "namespace_cp";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		verifyState();

		rwc_->cp(fd, source, sourcefd);
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}
}


void clusterio_ReadWriteServiceImpl::system_cp (
    const clusterio::file_handle & fd,
    const char * destHost,
    CORBA::Long destFilePort,
    CORBA::Long destAuditPort
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
	const char *op = "system_cp";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		verifyState();

		rwc_->cp(fd, destHost, destFilePort, destAuditPort);
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}
}


void clusterio_ReadWriteServiceImpl::namespace_token (
    const clusterio::file_handle & fd,
    CORBA::Long append_token
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
	const char *op = "namespace_token";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		verifyState();

		rwc_->setAppendToken(fd, append_token);
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}
}


void clusterio_ReadWriteServiceImpl::namespace_rm (
    const clusterio::file_handle & fd
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
	const char *op = "namespace_rm";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		verifyState();

		rwc_->rm(fd);
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}
}


CORBA::Boolean clusterio_ReadWriteServiceImpl::namespace_unrm (
    const clusterio::file_handle &
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
	const char *op = "namespace_unrm";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_ALARM("%s not implemented yet", op);

	emitTime(startT, op);
	throw Service::ServiceException(0, "Not implemented yet");
}


void clusterio_ReadWriteServiceImpl::dumpState (
    const char *what,
    clusterio::ReadWriteService::dump_format fmt,
    clusterio::ReadWriteService::detail_level lvl,
    CORBA::String_out out
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
	const char *op = "dumpState";
	struct timeval startT;
	std::ostringstream oss;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	if (fmt == clusterio::ReadWriteService::html)
	{
		oss << "<html>\n<body>\n";
	}

	if ((::strcmp(what, "rws") == 0) || (::strcmp(what, "all") == 0))
	{
		oss << "rws.pendingShutdown: " << isPendingShutdown_ << "\n";
		if ((lvl >= clusterio::ReadWriteService::regular) && (cfg_ != (Config *) 0))
		{
			char_ptr_vec *v = cfg_->getKeys();

			if (fmt == clusterio::ReadWriteService::html)
			{
				oss << "<table>";
			}

			for (size_t i = 0; i < v->size(); i++)
			{
				char_ptr key = (*v)[i];

				const char *val = cfg_->findString(key.get());

				if (fmt == clusterio::ReadWriteService::html)
				{
					oss << "<tr><td>" << key.get() << "</td><td>" << val << "</td></tr>\n";
				}
				else
				{
					oss << key.get() << "=" << val << "\n";
				}
			}

			if (fmt == clusterio::ReadWriteService::html)
			{
				oss << "</table>";
			}
			delete v;
		}
	}
	else
	{
		if (rwc_ != (ReadWriteController *) 0)
		{
			rwc_->dumpState(what, fmt, lvl, oss);
		}
	}

	if (fmt == clusterio::ReadWriteService::html)
	{
		oss << "</body>\n</html>\n";
	}

	std::string s = oss.str();

	out = s.c_str();

	emitTime(startT, op);
}


void clusterio_ReadWriteServiceImpl::restart()
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
	const char *op = "restart";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	isPendingShutdown_ = true;

	try {
		int cnt = waitForZeroConnections(MAX_TIME_TO_WAIT);

		if (cnt != 0)
		{
			throw Service::ServiceException(0, "Gave up waiting for zero users");
		}

		init((Config *) 0);
		isPendingShutdown_ = false;
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}
}


::clusterio::ReadWriteService::log_level clusterio_ReadWriteServiceImpl::logLevel (
    clusterio::ReadWriteService::log_level lvl
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
	clusterio::ReadWriteService::log_level retVal;
	AppLog *inst = AppLog::instance();
	Log::elevel curr = inst->getMinLogLevel();

	switch (curr) {
	case Log::log_debug:
		retVal = clusterio::ReadWriteService::debug;
		break;
	case Log::log_info:
		retVal = clusterio::ReadWriteService::info;
		break;
	case Log::log_warn:
		retVal = clusterio::ReadWriteService::warn;
		break;
	case Log::log_alarm:
		retVal = clusterio::ReadWriteService::alarm;
		break;
	case Log::log_abort:
		retVal = clusterio::ReadWriteService::abort;
		break;
	case Log::log_ignore_all:
		retVal = clusterio::ReadWriteService::ignore_all;
		break;
	default:
		APPLOG_WARN("Unknown log level of %d", curr);
		retVal = clusterio::ReadWriteService::warn;
		break;
	}

	if (lvl != clusterio::ReadWriteService::inquiry)
	{
		switch (lvl) {
		case clusterio::ReadWriteService::debug:
			inst->setMinLogLevel(Log::log_debug);
			break;
		case clusterio::ReadWriteService::info:
			inst->setMinLogLevel(Log::log_info);
			break;
		case clusterio::ReadWriteService::warn:
			inst->setMinLogLevel(Log::log_warn);
			break;
		case clusterio::ReadWriteService::alarm:
			inst->setMinLogLevel(Log::log_alarm);
			break;
		case clusterio::ReadWriteService::abort:
			inst->setMinLogLevel(Log::log_abort);
			break;
		case clusterio::ReadWriteService::ignore_all:
			inst->setMinLogLevel(Log::log_ignore_all);
			break;
		default:
			APPLOG_WARN("Unknown log level of %d", lvl);
			break;
		}
	}

	return retVal;
}


void clusterio_ReadWriteServiceImpl::ping()
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
	const char *op = "ping";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	verifyState();

	emitTime(startT, op);
	APPLOG_DBG("%s end", op);
}


::Service::ServiceStatus * clusterio_ReadWriteServiceImpl::pullStatus (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
	::Service::ServiceStatus *retVal;
	const char *op = "pullStatus";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		Config cfg;

		if (rwc_ != (ReadWriteController *) 0)
		{
			rwc_->pullStatus(cfg);
		}
		retVal = SharedServiceMain::instance()->makeStatus(isPendingShutdown_, cfg);

		retVal->statusReceivedTime = time(0);
		retVal->live = (bool)(rwc_ != (ReadWriteController *) 0);
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}

	return retVal;
}


void clusterio_ReadWriteServiceImpl::reconfigure (
    const Service::NVPairList & configuration
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
	const char *op = "reconfigure";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		verifyState();

		rwc_->reconfigure(configuration);
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}
}


void clusterio_ReadWriteServiceImpl::forcedFailureConfiguration (
    const Service::NVPairList & configuration
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
	const char *op = "forcedFailureConfiguration";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	try {
		verifyState();

		if (rwc_ != (ReadWriteController *) 0)
		{
			ConfigPtr cp = NVPairUtil::convert(configuration);

			rwc_->setFailureConfig(*(cp.get()));
		}
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}
}


void clusterio_ReadWriteServiceImpl::gracefulShutdown (
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
	const char *op = "gracefulShutdown";
	struct timeval startT;

	DateUtils::getTime(startT);
	APPLOG_DBG("%s start", op);

	isPendingShutdown_ = true;

	try {
		int cnt = waitForZeroConnections(MAX_TIME_TO_WAIT);

		if (cnt != 0)
		{
			throw Service::ServiceException(0, "Gave up waiting for zero users");
		}

		SharedServiceMain::instance()->shutdown();
		APPLOG_DBG("%s end", op);
		emitTime(startT, op);
	} catch (CORBA::SystemException &se) {
		APPLOG_ALARM("%s caught CORBA:SystemException: %s", op, se._info().rep());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (clusterio::ClusterIOException &cie) {
		logClusterIOException(op, cie);
		emitTime(startT, op, __LINE__);
		throw;
	} catch (Service::ServiceException &se) {
		APPLOG_ALARM("%s caught a Service::ServiceException: %d %s", op, se.errno_short, se.what_string.in());
		emitTime(startT, op, __LINE__);
		throw;
	} catch (std::exception &e) {
		APPLOG_ALARM("%s caught a std::exception: %s", e.what());
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, e.what());
	} catch (...) {
		APPLOG_ALARM("%s caught something", op);
		emitTime(startT, op, __LINE__);
		throw Service::ServiceException(0, __PRETTY_FUNCTION__);
	}
}
