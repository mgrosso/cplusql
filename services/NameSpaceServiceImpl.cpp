// -*- C++ -*-
//
// $Id: NameSpaceServiceImpl.cpp,v 1.7 2004/08/11 22:41:51 mgrosso Exp $

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:1030

#include <time.h>

#include <map>
#include <list>
#include <string>

#include "Exclusion.h"
#include "AppExceptionHandler.h"
#include "AppLog.h"
#include "AppConfig.h"
#include "ConfigDump.h"
#include "hashFuncs.h"
#include "RegexMatchExpression.h"

#include "serviceC.h"
#include "clusterioC.h"
#include "clusterioI.h"

#include "NodeCntl.h"
#include "NVPairUtil.h"
#include "SharedServiceMain.h"
#include "keys.h"

#include "NameSpaceServiceImpl.h"

using namespace std ;
using namespace clusterio ;

struct file_info_t 
{
    clusterio::private_file_id      id;
    clusterio::unix_time_t          time_name_created;
    clusterio::unix_time_t          last_time_name_changed;
    Service::ServiceRefList         servants;
};


typedef struct 
{
    Service::ServiceStatus          status_ ;
    ConfigPtr                       details_ ;
    bool                            harderrors_ ;
    bool                            dead_ ; // missing heartbeats
    bool                            oos_ ;//$NODE_CNTL_DIR/${hostname_}.oos 

    size_t                          diskfree_ ;
    unsigned long long              instance_ ;

} rwnode_info_t ;
typedef ptr< rwnode_info_t >        RWNodePtr ;

//
// the namespace_t typedef is good enough for a hello world level
// implementation only. this needs to use prefix compression if its going to
// be close to scalable enough. see CharMap.h. 
//
typedef map< string, file_info_t, string_less_than >        namespace_t ;
typedef list< RWNodePtr >                                   nodelist_t ;
typedef map<string,nodelist_t::iterator,string_less_than>   nodesbyname_t ;
typedef map< string, RWNodePtr, string_less_than >          nodesmap_t ;

class  NameSpaceServiceImplPriv 
{
    private:
    friend class NameSpaceServiceImpl;

    namespace_t                     names_ ;
    nodelist_t                      nodelist_ ;
    nodelist_t::iterator            nextnode_ ;
    nodesbyname_t                   nodesbyname_ ;
    nodesmap_t                      badnodes_ ;
    Mutex                           lock_ ;
    clusterio::private_file_id      nextid_ ;
    NodeCntlPtr                     ndcntl_;
    bool                            anyNodes_ ;

    void populate_file_name_status( 
        clusterio::file_name_status &status, 
        const struct file_info_t &info, 
        const char *name );

    void open( 
        const char * filename,
        CORBA::Short copies,
        clusterio::flag_t flags,
        const char * preferred_host,
        clusterio::open_info &oi  );

    void newid( clusterio::private_file_id &nid );
    void allocateNodes( 
        Service::ServiceRefList &servants, 
        CORBA::Short copies, 
        const char *preferred  );
    void badNode( const string &host, RWNodePtr &node );
};

void 
NameSpaceServiceImplPriv::badNode( const string &host, RWNodePtr &node )
{
    (void)nodesbyname_.erase( host );
    if( badnodes_.find(host) == badnodes_.end())
    {
        badnodes_[ host ] = node ;
    }
}

void
NameSpaceServiceImplPriv::populate_file_name_status( 
        file_name_status &status, 
        const struct file_info_t &info, 
        const char *name )
{
    status.filename = name ;
    status.time_name_created = info.time_name_created ;
    status.last_time_name_changed = info.last_time_name_changed ;
    status.servants = info.servants ;
    APPLOG_DBG( "file=%s creat=%lu last=%lu servants=%lu",
        status.filename.in(),
        status.time_name_created,
        status.last_time_name_changed,
        status.servants.length());
}

void
NameSpaceServiceImplPriv::open( 
        const char * filename,
        CORBA::Short copies,
        clusterio::flag_t flags,
        const char * preferred_host,
        clusterio::open_info &oi  )
{
    string s=filename;
    if(
        ( flags & o_excl && ! flags & o_creat ) ||
        ( flags & o_rdonly && flags & o_wronly ) || 
        ( flags & o_rdonly && flags & o_creat )
    )
    {
        PANICV("incompatible flags, %i", flags );
    }
    namespace_t::iterator i = names_.find( s );
    if( i != names_.end())
    {
        if( flags & clusterio::o_excl )
        {
            PANICV("o_excl, but file allready exists");
        }
        oi.servants = (*i).second.servants ;
        oi.handle.id = (*i).second.id ;
        oi.handle.flags = flags ;
        return;
    }
    //file does not exist. create it?
    if( ! ( flags & clusterio::o_wronly ) ||
        ! ( flags & clusterio::o_creat ) )
    {
        PANICV("file does not exist, but not opened with o_creat and o_wronly");
    }
    //create file_info.
    struct file_info_t info;
    newid( info.id  );
    allocateNodes( oi.servants, copies, preferred_host  );
    info.servants = oi.servants ;
    info.last_time_name_changed = info.time_name_created = time(NULL);

    //store file info
    names_[s] = info ;

    oi.handle.id = info.id ;
    oi.handle.debug_info = s.c_str();
    oi.handle.flags = flags;
    oi.servants = info.servants ;
}

void 
NameSpaceServiceImplPriv::newid( clusterio::private_file_id &nid )
{
    nid = nextid_ ;
    if( ! ++nextid_  )
    {
        PANICV("either we created our 2^64th file, or there is a bug.");
    }
}

void
NameSpaceServiceImplPriv::allocateNodes( 
    Service::ServiceRefList &servants, 
    CORBA::Short copies, 
    const char *preferred_host  )
{
    unsigned int ucopies = static_cast<unsigned int>(copies);
    if( ! copies )
    {
        return;
    }
    if( !anyNodes_ )
    {
        PANICV("no nodes available" );
    }
    if( nodesbyname_.size() < ucopies )
    {
        PANICV("not enough nodes available, want %i have %i", 
            ucopies, nodesbyname_.size());
    }

    nodelist_t::iterator n = nextnode_;
    if( preferred_host )
    {
        string preferred( preferred_host );
        nodesbyname_t::iterator inames = nodesbyname_.find( preferred );
        nodesbyname_t::iterator enames = nodesbyname_.end();
        if( inames != enames )
        {
            n = (*inames).second ;
        }
    }
    servants.length( ucopies ); 
    for( unsigned int i=0; i< ucopies; ++i, ++n )
    {
        if( n == nodelist_.end())
        {
            n = nodelist_.begin();
        }
        servants[i] = (*n)->status_.ref ;
    }
    if(( preferred_host != NULL && *preferred_host != '\0' ) && 
        ( ++ nextnode_ == nodelist_.end()))
    {
        nextnode_ = nodelist_.begin();
    }
}

// Implementation skeleton constructor
NameSpaceServiceImpl::NameSpaceServiceImpl (void)
{
    d_ = new NameSpaceServiceImplPriv();
    {
        d_->nextid_ =1;
    }
    d_->ndcntl_ = SharedServiceMain::makeNodeCntl();
    d_->anyNodes_ = false ;
}

// Implementation skeleton destructor
NameSpaceServiceImpl::~NameSpaceServiceImpl (void)
{
    delete d_;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

CORBA::Boolean NameSpaceServiceImpl::stat (
    const char * filename,
    clusterio::file_name_status_out status
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try{
        APPLOG_DBG("stat(%s)", filename);
        string s=filename;
        MutexGuard mg ( d_->lock_ );
        namespace_t::iterator i = d_->names_.find( s );
        if( i == d_->names_.end())
        {
            return false;
        }
        d_->populate_file_name_status( *(status.ptr()), (*i).second, s.c_str()) ;
        APPLOG_DBG("stat(%s) done", filename);
        return true;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "caught unknown exception");
        err.what_string = "stat() caught unknown exception";
    }
    throw err;
    //not reached
    return false;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

::clusterio::FileNameStatusList * NameSpaceServiceImpl::find (
    const char * prefix,
    const char * pattern
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try{
        APPLOG_DBG("find(%s, %s)", prefix, pattern);
        size_t sz = strlen( prefix );
        list< file_info_t * > ls;
        list< const char * > names;

        ExpressionPtr empty;
        RegexMatchExpression rme( empty, pattern, false );

        MutexGuard mg ( d_->lock_ );
        namespace_t::iterator i = d_->names_.begin();
        namespace_t::iterator e = d_->names_.end();
        for( ; i != e ; ++i )
        {
            if( ! strncmp( prefix, (*i).first.c_str(), sz ))
            {
                if( rme.match( (*i).first.c_str()))
                {
                    ls.push_back( & (*i).second );
                    names.push_back( (*i).first.c_str());
                }
            }
        }
        FileNameStatusList *gb = new FileNameStatusList();
        gb->length( ls.size());
        while( ls.size())
        {
            d_->populate_file_name_status( 
                (*gb)[ ls.size() - 1 ], *ls.front(), names.front());
            ls.pop_front() ;
            names.pop_front() ;
        }
        APPLOG_DBG("find(%s, %s) done", prefix, pattern);
        return gb;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "find(%s, %s) caught(%s)", prefix, pattern, e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "find(%s, %s) caught(%s)", prefix, pattern, "unknown exception");
        err.what_string = "find() caught unknown exception";
    }
    throw err;
    //not reached
    return NULL;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

::clusterio::open_info * NameSpaceServiceImpl::open (
    const char * filename,
    CORBA::Short copies,
    clusterio::flag_t flags,
    const char * preferred_host
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try{
        MutexGuard mg ( d_->lock_ );
        APPLOG_DBG("open(%s, %i, %u, %s)", filename, copies, flags, preferred_host );
        clusterio::open_info * giveback = new clusterio::open_info();
        d_->open( filename, copies, flags, preferred_host, *giveback );

        APPLOG_DBG("open(%s, %i, %u, %s) done", filename, copies, flags, preferred_host );
        return giveback;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "exception %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown exception" );
        err.what_string = "open() caught unknown exception";
    }
    throw err;
    //not reached
    return NULL;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

::clusterio::open_info_seq * NameSpaceServiceImpl::open_seq (
    const clusterio::filename_seq & filenames,
    CORBA::Short copies,
    clusterio::flag_t flags,
    const char * preferred_host
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    clusterio::open_info_seq * giveback = NULL ;
    try{
        MutexGuard mg ( d_->lock_ );
        APPLOG_DBG("open_seq( %u names, %i, %u, %s)", 
            filenames.length(), copies, flags, preferred_host );
        giveback = new open_info_seq();
        size_t sz = filenames.length();
        giveback->length( sz );
        for( unsigned int i=0; i < sz; ++i )
        {
            d_->open( filenames[i], copies, flags, preferred_host, 
                (*giveback)[i] );
        }
        APPLOG_DBG("open_seq( %u names, %i, %u, %s)", 
            filenames.length(), copies, flags, preferred_host );
        return giveback ;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "exception %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown exception" );
        err.what_string = "open_seq() caught unknown exception";
    }
    if( giveback )
    {
        delete giveback ;
    }
    throw err;
    //not reached
    return NULL;
}

::clusterio::open_info_seq * 
NameSpaceServiceImpl::find_open_seq (
    const char * prefix,
    const char * pattern,
    CORBA::Short copies,
    clusterio::flag_t flags,
    const char * preferred_host
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try{
        size_t sz = strlen( prefix );
        list< const char * > names;

        ExpressionPtr empty;
        RegexMatchExpression rme( empty, pattern, false );

        if( flags & o_excl )
        {
            PANICV("There is no point in using o_excl with find_open_seq (think about it for a second)" );
        }

        MutexGuard mg ( d_->lock_ );
        APPLOG_DBG("find_open_seq( %s, %s, %i, %u, %s)", prefix, pattern, copies, flags, preferred_host );
        namespace_t::iterator i = d_->names_.begin();
        namespace_t::iterator e = d_->names_.end();
        for( ; i != e ; ++i )
        {
            if( ! strncmp( prefix, (*i).first.c_str(), sz ))
            {
                if( rme.match( (*i).first.c_str()))
                {
                    names.push_back( (*i).first.c_str());
                }
            }
        }
        open_info_seq *gb = new open_info_seq();
        gb->length( names.size());
        for( int j=0; ! names.empty() ; ++j, names.pop_front())
        {
            d_->open( names.front(), copies, flags, 
                preferred_host, (*gb)[j] );
        }
        APPLOG_DBG("find_open_seq( %s, %s, %i, %u, %s) done", prefix, pattern, copies, flags, preferred_host );
        return gb;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "excption %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown excption" );
        err.what_string = "find_open_seq() caught unknown exception";
    }
    throw err;
    //not reached
    return NULL;
}

void NameSpaceServiceImpl::mv (
    const char * from,
    const char * to
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try{
        MutexGuard mg ( d_->lock_ );
        APPLOG_DBG("mv( %s, %s)", from, to );
        string sfrom( from );
        string sto( to );
        namespace_t::iterator i = d_->names_.find( sfrom );
        namespace_t::iterator e = d_->names_.end();
        if( i == e )
        {
            PANICV( "mv( %s -> %s): from not found", sfrom.c_str(), sto.c_str()) ;
        }
        namespace_t::iterator j = d_->names_.find( sto );
        if( j != e )
        {
            PANICV( "mv( %s -> %s): to allready exists, use mvclobber() instead", sfrom.c_str(), sto.c_str()) ;
        }
        (*i).second.last_time_name_changed = time( NULL );
        d_->names_[ sto ] = (*i).second ;
        d_->names_.erase( sfrom );
        APPLOG_DBG("mv( %s, %s) done", from, to );
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "excption %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown excption" );
        err.what_string = "mv() caught unknown exception";
    }
    throw err;
}

void NameSpaceServiceImpl::mvclobber (
    const char * from,
    const char * to
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try{
        MutexGuard mg ( d_->lock_ );
        APPLOG_DBG("mv( %s, %s)", from, to );
        string sfrom( from );
        string sto( to );
        namespace_t::iterator i = d_->names_.find( sfrom );
        namespace_t::iterator e = d_->names_.end();
        if( i == e )
        {
            PANICV( "mv( %s -> %s): from not found", sfrom.c_str(), sto.c_str()) ;
        }
        namespace_t::iterator j = d_->names_.find( sto );
        if( j != e )
        {
            d_->names_.erase( sto ); 
        }
        (*i).second.last_time_name_changed = time( NULL );
        d_->names_[ sto ] = (*i).second ;
        d_->names_.erase( sfrom );
        APPLOG_DBG("mv( %s, %s) done", from, to );
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "excption %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown excption" );
        err.what_string = "mv() caught unknown exception";
    }
    throw err;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void NameSpaceServiceImpl::rm (
    const char * file
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try{
        MutexGuard mg ( d_->lock_ );
        APPLOG_DBG("rm( %s )", file );
        string sfile( file );
        namespace_t::iterator i = d_->names_.find( sfile );
        namespace_t::iterator e = d_->names_.end();
        if( i == e )
        {
            PANICV( "rm(%s): file not found", sfile.c_str()) ;
        }
        //TODO d_->rmq_.push( sfile );
        d_->names_.erase( sfile );
        APPLOG_DBG("rm( %s ) done", file );
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "excption %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown excption" );
        err.what_string = "rm() caught unknown exception";
    }
    throw err;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

clusterio::length_t NameSpaceServiceImpl::find_rm (
    const char * prefix,
    const char * pattern
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try{
        clusterio::length_t giveback = 0 ;
        size_t sz = strlen( prefix );
        list< const char * > names;
        ExpressionPtr empty;
        RegexMatchExpression rme( empty, pattern, false );

        MutexGuard mg ( d_->lock_ );
        APPLOG_DBG("find_rm( %s, %s )", prefix, pattern );
        namespace_t::iterator i = d_->names_.begin();
        namespace_t::iterator e = d_->names_.end();
        for( ; i != e ; ++i )
        {
            if( ! strncmp( prefix, (*i).first.c_str(), sz ))
            {
                if( rme.match( (*i).first.c_str()))
                {
                    d_->names_.erase( (*i).first );
                    ++giveback;
                    //TODO d_->rmq_.push( sfile );
                }
            }
        }
        APPLOG_DBG("find_rm( %s, %s ) done", prefix, pattern );
        return giveback ;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "excption %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown excption" );
        err.what_string = "find_rm() caught unknown exception";
    }
    throw err;
    //not reached
    return 0;
}

::clusterio::clusterIOErrorAction 
NameSpaceServiceImpl::failure (
    clusterio::open_info & fileinfo,
    const clusterio::IOExceptionStructList & exceptions
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    APPLOG_DBG("failure( %llu, %s, %u )", 
        fileinfo.handle.id, 
        fileinfo.handle.debug_info.in(),
        fileinfo.handle.flags
        );
    return fail ;
}

void NameSpaceServiceImpl::pushStatusList (
    const Service::ServiceStatusList & stats
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    Service::ServiceException err;
    try{
        MutexGuard mg ( d_->lock_ );
        APPLOG_DBG("top" );
        size_t minfree=AppConfig::instance()->getInt(NSS_RWS_MINFREE,"1");

        string nexthostname ;
        if( d_->anyNodes_ )
        {
            nexthostname = (*d_->nextnode_)->status_.ref.hostname ;
        }

        //look up each hostname in our list of iterators, and then
        //insert and/or modify the corresponding status.
        for( unsigned i = 0; i< stats.length(); ++i )
        {
            //for each loop iteration, we will be sure there is a RWNodePtr
            //for this ServiceStatus and we will know it either exists in
            //nodesbyname_ and nodelist_, or it exists in badnodes_.
            //nodelist_ will no longer be garuanteed to be sorted in any
            //order though.

            string host = stats[i].ref.hostname.in() ;  
            APPLOG_DBG("toploop %i, %s", i, host.c_str());

            nodesbyname_t::iterator enames = d_->nodesbyname_.end();
            nodesbyname_t::iterator inames = d_->nodesbyname_.find(host);
            RWNodePtr np ;
            if( inames != enames )
            {
                np = *((*inames).second) ;
            }
            else
            {
                nodesmap_t::iterator eb = d_->badnodes_.end();
                nodesmap_t::iterator ib = d_->badnodes_.find(host);
                if( ib != eb )
                {
                    np = (*ib).second ;
                }
                else
                {
                    APPLOG_DBG("node is new");
                    np = new rwnode_info_t;
                    np->status_ = stats[i] ;
                    np->harderrors_ = false ;
                    np->dead_ = false ;
                    //this will invalidate sorting of nodelist_, for now...
                    d_->nodelist_.push_front( np );
                    d_->nodesbyname_[host]=d_->nodelist_.begin(); 
                }
            }
            np->oos_ = ! d_->ndcntl_->isOK(host.c_str()) ;
            np->dead_ = (! stats[i].live ) || stats[i].isPendingShutdown ; 

            ConfigPtr cp = NVPairUtil::convert( stats[i].details );
            np->details_=cp;
            if( ! np->details_->findString( "BLOCK_FREE" ))
            {
                APPLOG_WARN("node %s status missing BLOCK_FREE",
                    host.c_str());
                np->diskfree_ = 0;
                d_->badNode( host, np );
                continue;
            }
            np->diskfree_ = np->details_->getInt( "BLOCK_FREE" );

            if( ! np->details_->findString( "RWS_INSTANCE_ID" ))
            {
                APPLOG_WARN("node %s has no INSTANCE_ID param",
                    host.c_str());
                np->instance_ = 0;
                d_->badNode( host, np );
                continue;
            }
            if( np->diskfree_ < minfree || np->harderrors_ || 
                np->dead_ || np->oos_)
            {
                APPLOG_WARN(
                    "bad node %s  diskfree=%i harderror=%i dead=%i oos=%i", 
                    host.c_str(), np->diskfree_, np->harderrors_, 
                    np->dead_, np->oos_);
                d_->badNode( host, np );
            }
            APPLOG_DBG("node is good");
        }

        //all new nodes are now in map and in list, but list may be out of
        //order, and we would like primary->backup mappings to be as stable
        //as possible, so we push each map element onto temp list in order
        //sorted by map, and set the maps list iterator to that list item.
        //Because we are trafficing in ptr<> the copy into a is relatively
        //cheap. Traversing a map from begin() to end() shoudl be O(N)
        APPLOG_DBG("reordering nodelist");


        nodelist_t a;
        nodesbyname_t::iterator e = d_->nodesbyname_.end();
        nodesbyname_t::iterator i = d_->nodesbyname_.begin();
        for( ; i!= e; ++i )
        {
            a.push_front( *((*i).second)  );
            (*i).second = a.begin() ;
        }

        //Now splice those elements back into main list. This happens in
        //constant time, and is not proportional to nodes as a copy would
        //be.
        d_->nodelist_.clear(); 
        d_->nodelist_.splice( d_->nodelist_.begin(), a );

        //restore the saved nexthost iterator
        if( d_->nodesbyname_.empty())
        {
            d_->anyNodes_ = false ;
            return;
        }
        if( ! d_->anyNodes_ )
        {
            d_->anyNodes_ = true ;
            i=d_->nodesbyname_.begin();
        }
        else if(e == ( i = d_->nodesbyname_.find( nexthostname )))
        {
            i=d_->nodesbyname_.begin();
        }
        d_->nextnode_ = (*i).second ;

        APPLOG_DBG("done" );
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "excption %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown excption" );
        err.what_string = "pushStatusList() caught unknown exception";
    }
    throw err;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void NameSpaceServiceImpl::ping (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    Service::ServiceException err;
    try{
        APPLOG_INFO("ping()");
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "excption %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown excption" );
        err.what_string = "ping() caught unknown exception";
    }
    throw err;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

::Service::ServiceStatus * NameSpaceServiceImpl::pullStatus (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try{
        Config c;
        MutexGuard mg ( d_->lock_ );
        APPLOG_DBG("...");
        char_ptr numfiles = ptr_strdup_long( d_->names_.size());
        c.addString( NSS_NUMFILES, numfiles.get(), true );

        char_ptr numnodes = ptr_strdup_long( 0 );
        c.addString( NSS_NUMNODES, numnodes.get(), true );

        char_ptr numrmthreads = ptr_strdup_long( 0 );
        c.addString( NSS_NUMRMTHREADS, numrmthreads.get(), true );

        char_ptr numcpthreads = ptr_strdup_long( 0 );
        c.addString( NSS_NUMCPTHREADS, numcpthreads.get(), true );

        return SharedServiceMain::instance()->makeStatus( false, c );
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "excption %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown excption" );
        err.what_string = "pullStatus() caught unknown exception";
    }
    throw err;
    return NULL;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void NameSpaceServiceImpl::reconfigure (
    const Service::NVPairList & configuration
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    MutexGuard mg ( d_->lock_ );
    SharedServiceMain::instance()->reconfigure( 
        configuration, AppConfig::instance());
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void NameSpaceServiceImpl::gracefulShutdown (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    Service::ServiceException err;
    try{
        PANICV("TODO");
        MutexGuard mg ( d_->lock_ );
    }
    catch( std::exception &e )
    {
        APPLOG_INFO( "excption %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_INFO( "unknown excption" );
        err.what_string = "gracefulShutdown() caught unknown exception";
    }
    throw err;
}

