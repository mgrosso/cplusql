// -*- C++ -*-
//
// $Id: JobExecServiceImpl.cpp,v 1.28 2004/05/20 17:02:40 mgrosso Exp $

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:1030


//idl generated includes
#include "serviceC.h"
#include "JobExecServiceC.h"
#include "JobQueueServiceC.h"

//cplusql includes.
#include "SharedServiceMain.h"
#include "JobExecServiceImpl.h"
#include "NVPairUtil.h"
#include "keys.h"

//libframe includes.
#include "ptr.h"
#include "ptr_strdup.h"
#include "AppLog.h"
#include "AppExceptionHandler.h"
#include "BaseException.h"
#include "Config.h"
#include "ConfigDump.h"
#include "Runnable.h"
#include "RunnableHandler.h"
#include "ThreadRunnable.h"
#include "Event.h"
#include "Exclusion.h"
#include "ExecWrap.h"
#include "EventQueueExitRunnable.h"
#include "hashFuncs.h"
#include "FileExistsExpression.h"

//std c++ includes
#include <map>
#include <set>

//c system includes
#include <time.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <signal.h>


typedef map<pid_t, const char * >   jobmap_t ;
typedef map<pid_t, time_t >         jobtimes_t ;
typedef set< string, string_less_than >         job_id_set ;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_is.cpp:52

class JobExecServiceRunnable : public Runnable
{
    public:
    JobExecServiceRunnable( 
        const struct JobQueue::JobQueueRef            &callback,
        const struct JobQueue::JobSubmissionStruct    &submission,
        JobExecServicePriv *                            priv
    );
    virtual void                            run();
    JobQueue::JobQueueService_ptr           resolve( const char *url );
    private:
    struct JobQueue::JobQueueRef            callback_ ;
    struct JobQueue::JobSubmissionStruct    submission_ ;
    JobExecServicePriv *                    priv_ ;
};

class JobExecServicePriv 
{
    private: 
    friend class JobExec_JobExecService_i ;
    friend class JobExecServiceRunnable ;

    ConfigPtr                   cfg_   ;
    time_t                      boot_  ;
    bool                        shutdown_ ;
    unsigned                    jobcount_ ;//==runlist_.size()
    unsigned                    maxjobs_ ;//==runlist_.size()
    Mutex                       list_lock_  ;
    EventQueuePtr               eq_;
    char_ptr_list               stale_dirs_ ;
    char_ptr_list               stale_files_ ;
    jobmap_t                    running_pids_ ;
    jobtimes_t                  running_jobtimes_ ;
    job_id_set                  running_jobids_ ;

    //helpers
    void cleanup( const char *filename, const char *suffix, bool isdir );
};

void
JobExecServicePriv::cleanup( const char *filename, const char *suffix, bool isdir )
{
    char_ptr newfilename  = ptr_strdup_plus( filename, suffix ) ;
    APPLOG_DBG( 
        "JobExecServiceRunnable::run(): rename [%s] to [%s]",
        filename, newfilename.get() );

    char_ptr cleanme ;
    int rn=rename( filename, newfilename.get()); 
    if( rn != 0 )
    {
        APPLOG_WARN( 
            "JobExecServiceRunnable::run(): could not rename [%s] to [%s], errno=%i",
            filename, newfilename.get(), errno );

        cleanme = ptr_strdup(filename);
    }
    else 
    {
        cleanme = newfilename ;
    }
    
    if( isdir )
    {
        stale_dirs_.push_front( cleanme );
    }
    else
    {
        stale_files_.push_front( cleanme );
    }
}


JobExecServiceRunnable::JobExecServiceRunnable(
    const struct JobQueue::JobQueueRef            &callback,
    const struct JobQueue::JobSubmissionStruct    &submission,
    JobExecServicePriv *                           priv
)
:callback_(callback),submission_(submission),priv_(priv)
{
    ;//noop
}

JobQueue::JobQueueService_ptr 
JobExecServiceRunnable::resolve( const char *url )
{
    CORBA::Object_ptr obj = SharedServiceMain::instance()->resolve( url );
    JobQueue::JobQueueService_ptr giveback = JobQueue::JobQueueService::_narrow( obj );
    return giveback ;
}

void
JobExecServiceRunnable::run()
{
    //
    //this is where we execute jobs.
    //we dont allow exceptions to propogate out of here, as when things go 
    //wrong we still have to send status back to the jobq and cleanup the directory.
    //
    char errbuf[BE_LEN];
    const char *jobid = submission_.jobId ;
    JobQueue::ExecutionStatusStruct status;
    status.jobId = jobid ;
    status.executionStatus = JobQueue::failed_on_node ;
    char_ptr output ;
    char_ptr error ;
    bool mkdirok = false ;


    try{
        APPLOG_DBG( "run(): job[%s]", jobid );

        ConfigPtr jobc = NVPairUtil::convert( 
            submission_.args.configuration );

        string jbcstr;
        ConfigDump::dumpToString( *jobc, jbcstr );
        APPLOG_DBG( "run(): job[%s] configuration(%s)", jobid, jbcstr.c_str());
        

        const char *jobdir = jobc->findString(JOB_STARTDIR);
        if( ! jobdir )
        {
            jobdir = jobid ;
            if( 0 != mkdir( jobdir, 0755 ))
            {
                PANICV( 
                    "run(): cant create job dir %s", 
                    jobdir );
            }
            mkdirok = true ; 
        }
        output = ptr_strdup_plus( jobid, ".out" );
        error = ptr_strdup_plus( jobid, ".err" );
        output = ptr_strdup( jobc->getString( JOB_OUTPUT, output.get()));
        error  = ptr_strdup( jobc->getString( JOB_ERROR, error.get()));

        APPLOG_DBG( "run(): job[%s] jobdir[%s], output[%s] error[%s]", 
            jobid, jobdir, output.get(), error.get());

        char_ptr command = ptr_strdup_wnull( submission_.args.command.in());

        unsigned elen =submission_.args.environment.length();
        argv_ptr ekeys = argv_ptr_new(elen+2);
        argv_ptr evals = argv_ptr_new(elen+2);
        unsigned i ;
        for( i=0 ; i< elen; ++i )
        {
            ekeys[i]=strdup_wnew( submission_.args.environment[i].name );
            evals[i]=strdup_wnew( submission_.args.environment[i].value );
            APPLOG_DBG( 
                "run(): job[%s], %s=%s",
                jobid, 
                submission_.args.environment[i].name.in(),
                submission_.args.environment[i].value.in()
                );
        }
        ekeys[i]=strdup_wnew( "JOB_ID" );
        evals[i++]=strdup_wnew( jobid );
        ekeys[i]=strdup_wnew( "JOB_EXEC_URL"); 
        evals[i]=strdup_wnew( AppConfig::instance()->getString( GS_MY_URL ));

        APPLOG_DBG( 
            "run(): job[%s], fork_exec_watch(%s)", 
            jobid, command.get() );

        //TODO: find a way to get applog closed, so child process does not inherit
        //that fd.
        pid_t pid = ExecWrap::fork_exec_watch(
            command.get(),
            NULL, NULL, NULL,
            NULL, output.get(), error.get(),
            ekeys.get(), evals.get(), elen, 
            jobdir
        );
        {
            MutexGuard g(priv_->list_lock_);
            priv_->running_pids_[ pid ]=jobid;
            priv_->running_jobtimes_[ pid ]=time(NULL);
        }
        APPLOG_DBG( 
            "JobExecServiceRunnable::run(): job[%s], command[%s] is pid[%i]",
            jobid, command.get(), static_cast<int>(pid ));

        int ret = ExecWrap::wait_for_exit_status( pid );
        {
            MutexGuard g(priv_->list_lock_);
            priv_->running_pids_.erase( pid );
            priv_->running_jobtimes_.erase( pid );
        }

        if( !ret )
        {
            const char *target = jobc->findString( JOB_TARGET );
            if( target )
            {
                FileExistsExpression fe( target );
                if( fe.getBool())
                {
                    status.executionStatus = JobQueue::succeeded_on_node ;
                }
            }
            else
            {
                status.executionStatus = JobQueue::succeeded_on_node ;
            }
        }
        else
        {
            //do nothing. perhaps in the future collect more info and 
            //place into results structure.
        }
        APPLOG_DBG( "JobExecServiceRunnable::run(): job[%s], returned [%i]",
            jobid, ret );
    }
    catch( std::exception &e )
    {
        AppExceptionHandler::instance()->handleLogOnly( e );
        snprintf( errbuf, BE_LEN - 1, 
            "JobExcecServiceImpl::run(): Job[%s] failed: %s", jobid, e.what() 
        );
    }
    catch( ... )
    {
        AppExceptionHandler::instance()->handleLogOnly();
        snprintf( errbuf, BE_LEN - 1, 
            "JobExcecServiceImpl: Job[%s] failed with an unknown exception", jobid );
    }
    errbuf[BE_LEN]='\0';

    if( callback_.url.in() == NULL )
    {
        APPLOG_ALARM( "JobExecServiceRunnable::run(): job[%s], null callback url", jobid );
    }
    else
    {
        unsigned int max_backoff = 300 ;
        unsigned int max_retry = 13 ;
        unsigned int backoff_factor = 8 ;
        {
            MutexGuard g(priv_->list_lock_);
            max_backoff         = priv_->cfg_->getInt( JE_MAX_BACKOFF, "300" );
            max_retry           = priv_->cfg_->getInt( JE_MAX_RETRY, "13" );
            backoff_factor      = priv_->cfg_->getInt( JE_BACKOFF_FACTOR, "8" );
        }
        const char *object_string = callback_.ior.in();

        bool callback_suceeded = false ;
        unsigned int retry =  0;
        unsigned int backoff = 0 ;
        for( retry = 0 ; ! callback_suceeded && retry < max_retry ; ++retry )
        {
            if( retry )
            {
                if( !backoff )
                {
                    backoff = 1 ;
                }
                else
                {
                    if((backoff *= backoff_factor ) > max_backoff )
                    {
                        backoff = max_backoff;
                    }
                }
                sleep( backoff );
            }

            try{
                APPLOG_DBG( 
                    "JobExecServiceRunnable::run(): job[%s], resolving jobq [%s][%s]... ", 
                    jobid, callback_.url.in(), object_string );

                JobQueue::JobQueueService_ptr jq = resolve( object_string );

                APPLOG_INFO( 
                    "JobExecServiceRunnable::run(): job[%s], calling jobFinished(%d)... ", 
                    jobid, status.executionStatus);

                jq->jobFinished( status );
                callback_suceeded = true ;

                APPLOG_DBG( 
                    "JobExecServiceRunnable::run(): job[%s], done calling back to jobq", 
                    jobid);
            }
            catch (CORBA::Exception &ce)
            {
                //AppExceptionHandler really needs to learn about CORBA...
                APPLOG_ABORT(
                    "JobExecServiceRunnable::run() caught CORBA::Exception in callback[%s][%s] on [%s]",
                    ce._rep_id(), ce._name(), object_string );
                //ior failed, try url instead.
                object_string = callback_.url.in();
            }
            catch( std::exception &e )
            {
                AppExceptionHandler::instance()->handleLogOnly( e );
            }
            catch( ... )
            {
                AppExceptionHandler::instance()->handleLogOnly();
            }
        }
    }

    time_t tdone = time( NULL );
    struct tm * tdonetm = localtime( &tdone );
    int timebufsz = 17 ;
    char timebuf [timebufsz];
    timebuf[0]='.';
    strftime( timebuf+1 , timebufsz-1, "%Y%m%d-%H%H%M", tdonetm );
    timebuf[timebufsz-1]='\0';

    try{
        MutexGuard g(priv_->list_lock_);
        if( submission_.args.exclusive )
        {
            priv_->jobcount_ = 0 ; 
        }
        else
        {
            -- priv_->jobcount_; 
        }
        APPLOG_DBG(
            "JobExecServiceRunnable::run(): job[%s], restored jobcount_ to %u", 
            jobid, priv_->jobcount_ );
   
        if( mkdirok )
        {
            priv_->cleanup(  jobid, timebuf, true );
            priv_->cleanup(  error.get(), timebuf, false );
            priv_->cleanup(  output.get(), timebuf, false );
        }
        priv_->running_jobids_.erase( jobid ) ;
    }
    catch( std::exception &e )
    {
        AppExceptionHandler::instance()->handleLogOnly( e );
    }
    catch( ... )
    {
        AppExceptionHandler::instance()->handleLogOnly();
    }
}


JobExec_JobExecService_i::JobExec_JobExecService_i (const Config &config)
{
    d_=new JobExecServicePriv();
    d_->cfg_=new Config(config);
    d_->boot_=time(NULL);
    d_->shutdown_=false;
    d_->jobcount_=0;
    d_->maxjobs_=d_->cfg_->getInt( JE_MAX_SLOTS, "1" );

    pEventFactory  nofactory;
    pEventHandler  handler=new RunnableHandler();
    unsigned int numthreads = d_->maxjobs_ ;
    if( numthreads < 10 )
    {
        numthreads = 10 ;
    }
    d_->eq_=new EventQueue( nofactory, handler, 0, numthreads, INT_MAX );

};

// Implementation skeleton destructor
JobExec_JobExecService_i::~JobExec_JobExecService_i (void)
{
    delete d_;
}

void JobExec_JobExecService_i::cleanupStaleOutput ()
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    APPLOG_INFO( "cleanupStaleOutput()" );
    Service::ServiceException err;
    try{
        MutexGuard g(d_->list_lock_);
        char_ptr_list::iterator i;
        char_ptr_list::iterator e;
        for( i= d_->stale_files_.begin(), e= d_->stale_files_.end(); i!=e; ++i )
        {
            APPLOG_DBG( "cleanupStaleOutput() unlink(%s)", (*i).get());
            int ret = unlink( (*i).get());
            if( ret != 0 )
            {
                APPLOG_WARN( 
                    "JobExecService::cleanupStaleOutput(): cant unlink [%s], errno=%i",
                    (*i).get(), errno );
            }
        }
        d_->stale_files_.clear() ;
        for( i= d_->stale_dirs_.begin(), e= d_->stale_dirs_.end(); i!=e; ++i )
        {
            char_ptr command = "rm -rf " + (*i) ;
            int rt = ExecWrap::fork_exec_wait( command.get());
            if( rt != 0 )
            {
                APPLOG_WARN( 
                    "JobExecService::cleanupStaleOutput(): cant rm -rf [%s], child wait() returns=%i",
                    (*i).get(), errno );
            }
        }
        d_->stale_dirs_.clear() ;
        return ;
    }
    catch( std::exception &e )
    {
        AppExceptionHandler::instance()->handleLogOnly( e );
        err.what_string = e.what();
    }
    catch( ... )
    {
        AppExceptionHandler::instance()->handleLogOnly();
        err.what_string = "cleanupStaleOutput() caught unknown exception";
    }
    throw err;
}

void
JobExec_JobExecService_i::killAllRunning ()
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    APPLOG_INFO( "killAllRunning()" );
    Service::ServiceException err;
    try{
        MutexGuard g(d_->list_lock_);
        if( d_->running_pids_.empty())
        {
            return;
        }

        jobmap_t::iterator i;
        jobmap_t::iterator e;
        for( 
            i= d_->running_pids_.begin(), e= d_->running_pids_.end(); 
            i!=e; 
            ++i )
        {
            (void)kill(-1 * (*i).first, SIGQUIT );
        }
        sleep(1);
        for( 
            i= d_->running_pids_.begin(), e= d_->running_pids_.end(); 
            i!=e; 
            ++i )
        {
            (void)kill(-1 * (*i).first, SIGKILL );
        }
        sleep(1);
        for( 
            i= d_->running_pids_.begin(), e= d_->running_pids_.end(); 
            i!=e; 
            ++i )
        {
            if( 0 == kill(-1 * (*i).first, 0 ))
            {
                APPLOG_WARN( 
                    "JobExecService::killAllRunning(): cant kill [%lu]", 
                    (*i).first );
            }
        }
        return ;
    }
    catch( std::exception &e )
    {
        AppExceptionHandler::instance()->handleLogOnly( e );
        err.what_string = e.what();
    }
    catch( ... )
    {
        AppExceptionHandler::instance()->handleLogOnly();
        err.what_string = "killAllRunning() caught unknown exception";
    }
    throw err;
}
 
// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

CORBA::Boolean JobExec_JobExecService_i::runJob (
    const JobQueue::JobQueueRef & jobQueueRef,
    const JobQueue::JobSubmissionStruct & jobSubmission
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    APPLOG_DBG( 
        "entering runJob():");
    const char *jobid = jobSubmission.jobId.in() ;

    if( d_->shutdown_ )
    {
        Service::PendingShutdownException shute;
        throw shute;
    }
    Service::ServiceException err;

    try{
        if( !jobid || 
            ! *jobid ||  
            ! jobSubmission.args.command.in()  ||
            ! *jobSubmission.args.command.in() 
        )
        {
            APPLOG_DBG("Ready to panic");
            PANICV( "runJob(): null arg jobid[%s], command[%s]", 
                jobid , jobSubmission.args.command.in() );
        }
        string jbcstr;
        ConfigPtr cp = NVPairUtil::convert( jobSubmission.args.configuration );
        ConfigDump::dumpToString( *cp, jbcstr );
        APPLOG_INFO( 
            "runJob(): top jobid[%s], command[%s] is exclusive?[%i] config[%s]", 
            jobid , jobSubmission.args.command.in(), jobSubmission.args.exclusive,
            jbcstr.c_str());

        MutexGuard g(d_->list_lock_);
        if(d_->jobcount_ >= d_->maxjobs_ )
        {
            APPLOG_INFO( 
                "runJob(): no room for job[%s], current jobcount[%i]", 
                jobid, d_->jobcount_ );
            return false;
        }
        if( d_->jobcount_  && jobSubmission.args.exclusive )
        {
            APPLOG_INFO( 
                "runJob(): no room for exlusive job[%s], current jobcount[%i]", 
                jobid, d_->jobcount_ );
            return false;
        }
        job_id_set::iterator i;
        job_id_set::iterator e;
        for( 
            i= d_->running_jobids_.begin(), e= d_->running_jobids_.end();
            i!=e;
            ++i 
            )
        {
            APPLOG_DBG( 
                "runJob(): will insert [%s], into set with member: [%s]", 
                jobid, (*i).c_str()
                );
        }
        if( 
                d_->running_jobids_.find( jobid )  != 
                d_->running_jobids_.end())
        {
            APPLOG_WARN( 
                "runJob(): job[%s], is allready running here!", 
                jobid );
            return false;
        }
        d_->running_jobids_.insert( jobid );
        Runnable *rp = new 
            JobExecServiceRunnable( jobQueueRef, jobSubmission, d_ );
        d_->eq_->push( rp );

        if( jobSubmission.args.exclusive )
        {
            d_->jobcount_ = d_->maxjobs_ ; 
        }
        else
        {
            ++ d_->jobcount_; 
        }

        APPLOG_DBG( "runJob(): job[%s] is on the q. new jobcount=%i", 
            jobid, d_->jobcount_ );
        return true;
    }
    catch(exception &e )
    {
        APPLOG_WARN( "runJob() caught execption: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_WARN( "runJob() caught unknown exception");
        err.what_string = "runJob() caught unknown exception";
    }
    throw err;
    //not reached.
    return false;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void JobExec_JobExecService_i::ping (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    if( d_->shutdown_ )
    {
        Service::PendingShutdownException shute;
        throw shute;
    }
    APPLOG_INFO( "ping()");
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

::Service::ServiceStatus * JobExec_JobExecService_i::pullStatus (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    APPLOG_DBG( "pullStatus()");

    Service::ServiceException err;
    try{
        Config c;
        char_ptr runningpids ( ptr_strdup( "" ));
        char_ptr runningjobids ( ptr_strdup( "" ));
        char_ptr runningjobtimes ( ptr_strdup( "" ));


        {
            MutexGuard g(d_->list_lock_);

            const char *delim = 
                d_->cfg_->getString( JE_STATUS_DELIM, "," );
            char_ptr jobcnt = ptr_strdup_long( d_->jobcount_ );
            char_ptr availjobs = ptr_strdup_long( 
                d_->maxjobs_ -d_->jobcount_ );
            char_ptr maxjobs = ptr_strdup_long( d_->maxjobs_ );

            c.addString( JE_USED_SLOTS, jobcnt.get(), true );
            c.addString( JE_AVAILABLE_SLOTS, availjobs.get(), true );
            c.addString( JE_MAX_SLOTS, maxjobs.get(), true );

            time_t now = time(NULL);

            jobmap_t::iterator i;
            jobmap_t::iterator e;
            jobtimes_t::iterator j;
            jobtimes_t::iterator je;
            for(
                i= d_->running_pids_.begin(), 
                    e= d_->running_pids_.end(), 
                    j= d_->running_jobtimes_.begin(), 
                    je= d_->running_jobtimes_.end(); 
                i!=e && j!=je;
                ++i, ++j )
            {
                if( '\0' != * runningpids.get())
                {
                    runningpids = runningpids + delim ;
                    runningjobids = runningjobids + delim ;
                    runningjobtimes = runningjobtimes + delim ;
                }
                runningpids = runningpids + ptr_strdup_long ((*i).first);
                runningjobids = runningjobids + (*i).second ;
                runningjobtimes = runningjobtimes + 
                    ptr_strdup_long(  now - (*j).second);
            }
        }
        c.addString( JE_RUNNING_PIDS, runningpids.get(), true );
        c.addString( JE_RUNNING_JOBIDS, runningjobids.get(), true );
        c.addString( JE_RUNNING_JOBTIMES, runningjobtimes.get(), true );

        return SharedServiceMain::instance()->makeStatus( d_->shutdown_, c );
    }
    catch(exception &e )
    {
        APPLOG_WARN( "pullStatus() caught execption: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_WARN( "pullStatus() caught unknown exception");
        err.what_string = "pullStatus() caught unknown exception";
    }
    throw err;
    //not reached.
    return NULL;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void JobExec_JobExecService_i::reconfigure (
    const Service::NVPairList & configuration
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    if( d_->shutdown_ )
    {
        Service::PendingShutdownException shute;
        throw shute;
    }
    MutexGuard g(d_->list_lock_);
    SharedServiceMain::instance()->reconfigure( 
        configuration, d_->cfg_.get() );
}


// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void JobExec_JobExecService_i::gracefulShutdown (
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    if( d_->shutdown_ )
    {
        Service::PendingShutdownException shute;
        throw shute;
    }
    Service::ServiceException err;
    try{
        //we leak the ThreadRunnable, which is not a big deal bc it calls
        //exit() anyhow.
        APPLOG_DBG( "gracefulShutdown() top.");
        RunnablePtr rp = new EventQueueExitRunnable( d_->eq_.get());
        //TODO: make it so this also schedules a cleanup stale files for after shutdown.
        ThreadRunnable *tr = 
            new ThreadRunnable( rp );
        tr->start();
        d_->shutdown_ = true ;
        d_->eq_->gracefulShutdown();
        APPLOG_INFO( "gracefulShutdown() started.");
    }
    catch(exception &e )
    {
        APPLOG_WARN( "gracefulShutdown() caught execption: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        APPLOG_WARN( "gracefulShutdown() caught unknown exception");
        err.what_string = "gracefulShutdown() caught unknown exception";
    }
    throw err;
}


