// -*- C++ -*-
//
// $Id: JobQueueServiceImpl.cpp,v 1.35 2004/09/30 22:36:00 mgrosso Exp $

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:985

#include "JobQueueServiceImpl.h"
#include "AppLog.h"
#include "ptr.h"
#include "ptr_strdup.h"
#include "StateQueues.h"
#include "Exclusion.h"
#include "ServiceStatusMap.h"
#include "Runnable.h"
#include "ThreadRunnable.h"
#include "SharedServiceMain.h"
#include "keys.h"

class SchedulerRunnable : public Runnable
{
  private:
    ServiceStatusMap* serviceStatusMap_;
    StateQueues* stateQueues_;
    int sleeptime_;

  public:
    SchedulerRunnable::SchedulerRunnable(
                                        ServiceStatusMap* serviceStatusMap,
                                        StateQueues* stateQueues,
                                        int sleeptime)
    {
        serviceStatusMap_ = serviceStatusMap;
        stateQueues_ = stateQueues;
        sleeptime_ = sleeptime;
    }

    void SchedulerRunnable::run()
    {
        while(1) 
        {
            try
            {
                APPLOG_DBG("in SchedulerRunnable::run(), calling stateQueues_->scheduleJobs(serviceStatusMap_)");
                stateQueues_->scheduleJobs(serviceStatusMap_);
                stateQueues_->printStateQueues("after scheduling jobs"); 
            }
            catch (CORBA::Exception &ce) 
            {
                //AppExceptionHandler really needs to learn about CORBA...
                APPLOG_ABORT("SchedulerRunnable::run() caught CORBA::Exception [%s][%s]", 
                    ce._rep_id(), ce._name() );
            }
            catch (std::exception &e) 
            {
                AppExceptionHandler::instance()->handleLogOnly( e );
            }
            catch ( ... )
            {
                AppExceptionHandler::instance()->handleLogOnly();
            }
            APPLOG_DBG("wait to schedule");
            stateQueues_->waitForSchedulable();
        }
    }
};

class JobQueueServicePriv
{
private:
    friend class JobQueue_JobQueueServiceImpl;

    JobQueueServicePriv()
    {
        ;//noop
    };

    ConfigPtr               cfg_   ;
    JobQueue::JobQueueRef   myRef_;

    char_ptr                hostname_;
    int                     pid_;
    bool                    isPendingShutdown_;

    StateQueues*            stateQueues_;
    ServiceStatusMap        serviceStatusMap_;
    Mutex                   lock_;

    ThreadRunnable*         schedulerThread_;
    int                     schedulerThreadSleeptime_;
};

// Implementation skeleton constructor
JobQueue_JobQueueServiceImpl::JobQueue_JobQueueServiceImpl (const Config &config)
{
    d_=new JobQueueServicePriv();
    d_->cfg_=new Config(config);
    d_->isPendingShutdown_=false;

    char hostname[256];
    gethostname(hostname, 256);
    // gethostname will truncate the name if it is longer than the buffer 
    // length passed in, and it is unspecifed whether the truncated
    // string will be nul terminated, so:
    hostname[255] = '\0';
    
    d_->hostname_=ptr_strdup(hostname);
    d_->pid_=getpid();
    d_->myRef_.serviceName="JobQueue";
    d_->myRef_.url=d_->cfg_->getString( GS_MY_URL );
    d_->myRef_.hostname=(const char*)hostname;
    
    d_->stateQueues_ = new StateQueues(&(d_->myRef_));
    d_->stateQueues_->initNodeMinRunnable( &d_->serviceStatusMap_ );
    
    d_->schedulerThreadSleeptime_ = 
        d_->cfg_->getInt( JQS_SCHEDULER_THREAD_SLEEPTIME, "10000000" );

    // check if there is a default service to which this service
    // should subscribe
    // Typically a JobQueueService will subscribe to the
    // central NodeMonitorService
    if(const char* defaultSubscribeTargetURL = d_->cfg_->findString(GS_DEFAULT_SUBSCRIBE_TARGET_URL)) 
    {
        APPLOG_INFO("defaultSubscribeTargetURL=%s", defaultSubscribeTargetURL);
        
        CORBA::Object_ptr obj = SharedServiceMain::instance()->resolve( defaultSubscribeTargetURL );

        // Now downcast the object reference to the appropriate type
        Service::NodeMonitorService_var nodeMonitorService =
          Service::NodeMonitorService::_narrow (obj);
        APPLOG_DBG("back from _narrow");

        if (CORBA::is_nil (nodeMonitorService.in ()))
        {
            PANICV("ERROR: nodeMonitorService.in () object reference is_nil for %s", defaultSubscribeTargetURL);
            return; // not reached
        }

        APPLOG_INFO("nodeMonitorService->subscribePushConsumer(%s), \"JobExecService\", \"*\")", d_->myRef_.url.in());
        nodeMonitorService->subscribePushConsumer(d_->myRef_, JE_NAME, "*");
    }

    APPLOG_DBG("new SchedulerRunnable(&(d_->serviceStatusMap_), %d", d_->schedulerThreadSleeptime_);
    Runnable* r =
        new SchedulerRunnable(&(d_->serviceStatusMap_), d_->stateQueues_, d_->schedulerThreadSleeptime_);
    RunnablePtr pSchedulerRunnable(r);
    
    d_->schedulerThread_ = new ThreadRunnable(pSchedulerRunnable);
    d_->schedulerThread_->start();
    APPLOG_DBG("leaving ctor()");
}
  
// Implementation skeleton destructor
JobQueue_JobQueueServiceImpl::~JobQueue_JobQueueServiceImpl (void)
{
  //TODO
}

char_ptr JobQueue_JobQueueServiceImpl::generateJobId () const
{
    MutexGuard(d_->lock_);
    struct timeval tv;
    struct timezone tz;

    gettimeofday(&tv, &tz);
    long secs=tv.tv_sec;
    long usecs=tv.tv_usec;

    char buf[strlen(d_->hostname_.get())+100];
    sprintf(buf, "%s-%d-%ld-%ld", d_->hostname_.get(), d_->pid_, secs, usecs);
    if (strlen(buf) > strlen(d_->hostname_.get())+99)
    {
        PANICV("buffer overflow in JobQueue_JobQueueServiceImpl::generateJobId strlen(%s)=%d", buf, strlen(buf));
    }
    return ptr_strdup(buf);
}

::JobQueue::JobIdList * JobQueue_JobQueueServiceImpl::submit (
    const JobQueue::ExecArgsList & execArgList
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    APPLOG_DBG("in submit()");
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        int length = execArgList.length();
        APPLOG_DBG("in JobQueueServiceImpl::submit: execArgList.length()=%d", length);

        JobQueue::job_id_t* jobIds = new JobQueue::job_id_t[length];
        for (int i=0; i<length; i++) {
            APPLOG_DBG("execArgList[%d].command.in()=%s", i, execArgList[i].command.in());
            char_ptr pJobId = generateJobId();
            APPLOG_DBG("after generateJobId(), pJobId=%s",pJobId.get());
        
            JobPtr job = new JobQueue::Job();
            job->jobSubmission.jobId=CORBA::string_dup(pJobId.get());
            job->jobSubmission.args=execArgList[i];
            job->jobState=JobQueue::ready;
            d_->stateQueues_->toReady(job);

            jobIds[i] = CORBA::string_dup(pJobId.get());
        }

        APPLOG_INFO("state of stateQueues after submit:");
        d_->stateQueues_->printStateQueues("after submit");
    
        JobQueue::JobIdList* jobIdList = new JobQueue::JobIdList(length, length, jobIds, 1);
        length = jobIdList->length();
        return jobIdList;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "submit() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "submit() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
    return NULL;
}

::JobQueue::JobStateIdList * 
JobQueue_JobQueueServiceImpl::waitForStatusList (
    const JobQueue::JobIdList & jobIds,
    const Service::time_t timeout
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    Service::ServiceException err;
    try
    {
        APPLOG_DBG("calling stateQueues.waitForStatusList");
        return d_->stateQueues_->waitForStatusList(jobIds, timeout);
    }
    catch( CORBA::Exception &ce )
    {
        APPLOG_DBG("waitForStatusList(): corba exception ( %s, %s )",
            ce._rep_id(), ce._name()
        );
        throw;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "waitForStatusList() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "waitForStatusList() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
    return NULL;
}

::JobQueue::JobStateId 
JobQueue_JobQueueServiceImpl::waitForStatus (
    const char * jobId,
    Service::time_t timeout
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    Service::ServiceException err;
    try
    {
        JobQueue::job_id_t job_ids[1];
        job_ids[0] = (char*)jobId;
        JobQueue::JobIdList jobIds(1, 1, job_ids);
        APPLOG_DBG("calling waitForStatusList on job id:%s", jobId );
        ::JobQueue::JobStateIdList * jobidlist = 
            waitForStatusList(jobIds, timeout);
        ::JobQueue::JobStateId giveback = (*jobidlist)[0];
        delete jobidlist ;

        APPLOG_DBG("returning %i from waitForStatus on job id:%s", 
            giveback, jobId );
        return giveback;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "waitForStatus() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "waitForStatus() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}
  
void 
JobQueue_JobQueueServiceImpl::jobFinished (
    const JobQueue::ExecutionStatusStruct & executionStatus
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    Service::ServiceException err;
    try
    {
        APPLOG_DBG("jobFinished(%s) top", executionStatus.jobId.in());
        d_->stateQueues_->jobFinished( executionStatus );
        APPLOG_DBG("jobFinished(%s) done", executionStatus.jobId.in());
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "jobFinished() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "jobFinished() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void JobQueue_JobQueueServiceImpl::killAllJobs (
    JobQueue::num_threads_t numThreads
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try
    {
        d_->stateQueues_->killAllJobs(&(d_->serviceStatusMap_), numThreads);
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "killAllJobs() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "killAllJobs() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void 
JobQueue_JobQueueServiceImpl::cleanupStaleOutput (
    JobQueue::num_threads_t numThreads
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
    Service::ServiceException err;
    try
    {
        d_->stateQueues_->cleanupStaleOutput(&(d_->serviceStatusMap_), numThreads);
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "cleanupStaleOutput() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "cleanupStaleOutput() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}

void JobQueue_JobQueueServiceImpl::shutdownNow (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
{
  // Add your implementation here
    Service::ServiceException err;
    try
    {
        int numThreads=20; // this should be passed in like in client calls to killAllJobs
        APPLOG_DBG("Service_JobQueueServiceImpl::gracefulShutdown ()");
        d_->isPendingShutdown_=true;
        d_->stateQueues_->killAllJobs(&(d_->serviceStatusMap_), numThreads);
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "shutdownNow() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "shutdownNow() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

void JobQueue_JobQueueServiceImpl::ping (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    // Add your implementation here
    APPLOG_DBG("In ping");
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "ping() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "ping() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}
  
::Service::ServiceStatus * JobQueue_JobQueueServiceImpl::pullStatus (
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
  {
    // Add your implementation here
    Service::ServiceException err;
    try
    {
        struct timeval tv;
        struct timezone tz;

        gettimeofday(&tv, &tz);

        APPLOG_DBG("Service_JobQueueServiceImpl::pullStatus()");
        Service::ServiceStatus* serviceStatus = 
            new Service::ServiceStatus();
        serviceStatus->ref = d_->myRef_;
        //initializing the statusReceivedTime to the creation time
        //although this is expected to be overwritten on the receiving end.
        serviceStatus->statusReceivedTime= tv.tv_sec;
        serviceStatus->pid= d_->pid_;
        serviceStatus->isPendingShutdown=d_->isPendingShutdown_;
        serviceStatus->live=true;

        APPLOG_DBG("Service_JobQueueServiceImpl::pullStatus returning:");
        // HO-R need to add queue states here !!!!
        d_->serviceStatusMap_.printServiceStatus(serviceStatus);

        return serviceStatus;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "pullStatus() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "pullStatus() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}

void JobQueue_JobQueueServiceImpl::reconfigure (
    const Service::NVPairList & configuration
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    //
    // SharedServiceMain does the required try catch here, 
    // so we can skip that bit.  We first delegate through 
    // StateQueue so this call can benefit from its mutex protection.
    //
    d_->stateQueues_->reconfigure( configuration );
}

void JobQueue_JobQueueServiceImpl::gracefulShutdown (
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        APPLOG_DBG("Service_JobQueueServiceImpl::gracefulShutdown ()");
        d_->isPendingShutdown_=true;
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "gracefulShutdown() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "gracefulShutdown() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}

void JobQueue_JobQueueServiceImpl::pushStatusList (
    const Service::ServiceStatusList & serviceStatusList
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
{
    // Add your implementation here
    APPLOG_DBG("In JobQueue_JobQueueServiceImpl::pushStatusList");
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try{
        d_->serviceStatusMap_.pushStatusList(serviceStatusList);
        APPLOG_DBG("calling confirmRunningJobs()");
        d_->stateQueues_->confirmRunningJobs(&(d_->serviceStatusMap_));
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "pushStatusList() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "pushStatusList() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}
