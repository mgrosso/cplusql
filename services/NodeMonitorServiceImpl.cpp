// -*- C++ -*-
//
// $Id: NodeMonitorServiceImpl.cpp,v 1.46 2004/05/19 19:53:43 holahrei Exp $

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:985

#include "NodeMonitorServiceImpl.h"
#include "BaseException.h"
#include "Exclusion.h"
#include "ptr.h"
#include "ptr_strdup.h"
#include "hashFuncs.h"
#include "Thread.h"
#include "ServiceStatusMap.h"
#include "Runnable.h"
#include "ThreadRunnable.h"
#include "AppLog.h"
#include "SharedServiceMain.h"
#include "keys.h"

typedef ptr<Service::ServiceStatus> ServiceStatusPtr;

typedef ptr<Service::ServiceRef> ServiceRefPtr;
typedef vector<ServiceRefPtr> ServiceRefVector;

typedef ptr<ThreadRunnable> ThreadRunnablePtr;
typedef map<const char_ptr, ThreadRunnablePtr, char_ptr_less_than > ThreadRunnableMap;

class LivenessRunnable : public Runnable
{
  private:
    ServiceStatusMap* serviceStatusMap_;
    int sleeptime_;
    int tolerance_;

  public:
    LivenessRunnable::LivenessRunnable(
                                        ServiceStatusMap* serviceStatusMap,
                                        int sleeptime,
                                        int tolerance)
    {
        serviceStatusMap_ = serviceStatusMap;
        sleeptime_ = sleeptime;
        tolerance_ = tolerance;
    }

    void LivenessRunnable::run()
    {
        while(1) 
        {
            try
            {
                APPLOG_DBG("calling serviceStatusMap_->evaluateLiveness(), tolerance_=%d, sleeptime_=%d", tolerance_, sleeptime_);
                // the evaluateLiveness method blocks on the ServiceStatusMaps's mutex
                serviceStatusMap_->evaluateLiveness(tolerance_);
            }
            catch (CORBA::Exception &ce) 
            {
                //AppExceptionHandler really needs to learn about CORBA...
                APPLOG_ABORT("caught CORBA::Exception [%s][%s]", 
                    ce._rep_id(), ce._name() );
            }
            catch (std::exception &e) 
            {
                AppExceptionHandler::instance()->handleLogOnly( e );
            }
            catch ( ... )
            {
                AppExceptionHandler::instance()->handleLogOnly();
            }
            usleep(sleeptime_);
        }
    }
};

class PushToSubscriberRunnable : public Runnable
{
  private:
    CORBA::ORB_var orb_;
    Service::ServiceRef serviceRef_;
    ServiceStatusMap* serviceStatusMap_;
    int sleeptime_;
    char_ptr serviceName_;
    char_ptr host_;

  public:
    PushToSubscriberRunnable::PushToSubscriberRunnable(
                                        Service::ServiceRef serviceRef,
                                        ServiceStatusMap* serviceStatusMap,
                                        int sleeptime,
                                        const char* serviceName,
                                        const char* host)
    {
        serviceRef_ = serviceRef;
        serviceStatusMap_ = serviceStatusMap;
        sleeptime_ = sleeptime;
        host_ = ptr_strdup(host);
        serviceName_ = ptr_strdup(serviceName);
        APPLOG_DBG("ctor: host_=%s, serviceName_=%s", host_.get(), serviceName_.get());
    };

    void PushToSubscriberRunnable::run()
    {
        while(1) 
        {
            try
            {
                // the elements method blocks on the ServiceStatusMaps's mutex
                ptr<Service::ServiceStatusList> pServiceStatusList = serviceStatusMap_->elements(serviceName_.get(), host_.get());

                APPLOG_INFO("Pushing ServiceStatusList with %d entries to %s %s, which requested host:%s, service:%s", 
                            pServiceStatusList->length(),
                            serviceRef_.serviceName.in(),
                            serviceRef_.url.in(), 
                            host_.get(), 
                            serviceName_.get());

                Service::NodeMonitorPushConsumer_var nodeMonitorPushConsumer ;

                if( ! SharedServiceMain::instance()->resolve_consumer( 
                        nodeMonitorPushConsumer, serviceRef_.ior.in()) && 
                    ! SharedServiceMain::instance()->resolve_consumer( 
                        nodeMonitorPushConsumer, serviceRef_.url.in())
                )
                {
                    PANICV("could not resolve url or ior for %s.", serviceRef_.url.in());
                }

                APPLOG_DBG("resolved reference, pushing status" );
                nodeMonitorPushConsumer->pushStatusList(*pServiceStatusList);

                APPLOG_DBG("reset ior" );
                serviceRef_.ior = SharedServiceMain::instance()->getORB()->object_to_string( 
                    nodeMonitorPushConsumer );
            }
            catch (CORBA::Exception &ce) 
            {
                //AppExceptionHandler really needs to learn about CORBA...
                APPLOG_ABORT("caught CORBA::Exception trying to push to subscriber %s [%s][%s]", 
                    serviceRef_.url.in(), ce._rep_id(), ce._name() );
            }
            catch (std::exception &e) 
            {
                AppExceptionHandler::instance()->handleLogOnly( e );
            }
            catch ( ... )
            {
                AppExceptionHandler::instance()->handleLogOnly();
            }
            APPLOG_DBG("usleep(%d)", sleeptime_);
            usleep (sleeptime_);
        }
    }
};

class PullFromRegistrantRunnable : public Runnable
{
  private:
    Service::ServiceRef serviceRef_;
    ServiceStatusMap* serviceStatusMap_;
    int sleeptime_;

  public:
    PullFromRegistrantRunnable::PullFromRegistrantRunnable(
                                        Service::ServiceRef serviceRef,
                                        ServiceStatusMap* serviceStatusMap,
                                        int sleeptime)
    {
        serviceRef_ = serviceRef;
        serviceStatusMap_ = serviceStatusMap;
        sleeptime_ = sleeptime;
    }

    void PullFromRegistrantRunnable::run()
    {
        while(1) 
        {
            try
            {
                Service::GenericService_var genericService ;

                if( ! SharedServiceMain::instance()->resolve_service( 
                        genericService, serviceRef_.ior.in()) && 
                    ! SharedServiceMain::instance()->resolve_service( 
                        genericService, serviceRef_.url.in())
                )
                {
                    PANICV("could not resolve url or ior for %s.", serviceRef_.url.in());
                }

                APPLOG_DBG("pullFromRegistrantRunnable::run() pullStatus() %s", serviceRef_.url.in());
                Service::ServiceStatus* serviceStatus = genericService->pullStatus();

                struct timeval tv;
                struct timezone tz;

                gettimeofday(&tv, &tz);
                serviceStatus->statusReceivedTime = tv.tv_sec;

                ptr<Service::ServiceStatus>pServiceStatus = serviceStatus;

                APPLOG_DBG("pullFromRegistrantRunnable::run() done pullStatus() for=%s", serviceRef_.url.in());
                serviceStatusMap_->printServiceStatus(pServiceStatus.get());

                if( pServiceStatus->ref.ior.in() == NULL ||
                    * pServiceStatus->ref.ior.in() == '\0' )
                {
                    pServiceStatus->ref.ior = 
                        SharedServiceMain::instance()->getORB()->object_to_string( genericService );
                }
                char_ptr pURL(ptr_strdup (pServiceStatus->ref.url) );
                serviceStatusMap_->put(pURL, pServiceStatus);

                serviceRef_.ior = SharedServiceMain::instance()->getORB()->object_to_string( 
                    genericService );
            }
            catch (CORBA::Exception &ce) 
            {
                //AppExceptionHandler really needs to learn about CORBA...
                APPLOG_ABORT("caught CORBA::Exception [%s][%s]", 
                    ce._rep_id(), ce._name() );
            }
            catch (std::exception &e) 
            {
                AppExceptionHandler::instance()->handleLogOnly( e );
            }
            catch ( ... )
            {
                AppExceptionHandler::instance()->handleLogOnly();
            }

            APPLOG_DBG("usleep(%d)", sleeptime_);
            usleep (sleeptime_);
        }
    }
};

// make the following a Runnable, and pass it into a ThreadRunnable
class NodeMonitorServicePriv
{
private:
    friend class Service_NodeMonitorServiceImpl;

    NodeMonitorServicePriv()
    {
        ;//noop
    };

    ConfigPtr               cfg_   ;
    Service::ServiceRef     myRef_;

    char_ptr                hostname_;
    int                     pid_;
    bool                    isPendingShutdown_;

    ServiceStatusMap        serviceStatusMap_;
    Mutex                   lock_;

    ThreadRunnable*         livenessThread_;
    int                     livenessThreadSleeptime_;
    int                     livenessTolerance_;

    ThreadRunnableMap       pushToSubscriberThreads_;
    int                     pushToSubscriberThreadSleeptime_;

    ThreadRunnableMap       pullFromRegistrantThreads_;
    int                     pullFromRegistrantThreadSleeptime_;
};

// Implementation skeleton constructor
Service_NodeMonitorServiceImpl::Service_NodeMonitorServiceImpl (const Config &config)
{
    d_=new NodeMonitorServicePriv();
    d_->cfg_=new Config(config);
    d_->isPendingShutdown_=false;

    char hostname[256];
    gethostname(hostname, 256);
    // gethostname will truncate the name if it is longer than the buffer 
    // length passed in, and it is unspecifed whether the truncated
    // string will be nul terminated, so:
    hostname[255] = '\0';
    
    d_->hostname_=ptr_strdup(hostname);
    d_->pid_=getpid();
    d_->myRef_.serviceName="NodeMonitor";
    d_->myRef_.url=d_->cfg_->getString( GS_MY_URL );
    d_->myRef_.hostname=(const char*)hostname;

    d_->livenessThreadSleeptime_ = 
        d_->cfg_->getInt(NMS_LIVENESS_THREAD_SLEEPTIME, "60000000" );
    d_->livenessTolerance_ = 
        d_->cfg_->getInt(NMS_LIVENESS_TOLERANCE, "300" );
    d_->pushToSubscriberThreadSleeptime_ = 
        d_->cfg_->getInt(NMS_SUBSCRIBER_THREAD_SLEEPTIME, "30000000" );
    d_->pullFromRegistrantThreadSleeptime_ = 
        d_->cfg_->getInt(NMS_REGISTRANT_THREAD_SLEEPTIME, "60000000" );

    Runnable* r =
        new LivenessRunnable(&(d_->serviceStatusMap_), d_->livenessThreadSleeptime_, d_->livenessTolerance_);
    RunnablePtr pRunnable(r);
    
    d_->livenessThread_ = new ThreadRunnable(pRunnable);
    d_->livenessThread_->start();

    // check if there is a default subscriber to this service
    // For instance, every local NodeMonitorService will have the 
    // central NodeMonitorService as a default subscriber to it.
    char central_nms_url[ 1024 ];
    snprintf( central_nms_url, 1023,
        "corbaname::%s:%s#%s",
        d_->cfg_->getString(NS_HOST),
        d_->cfg_->getString(NS_PORT),
        d_->cfg_->getString(NMS_DEFAULT_SUBSCRIBER_SERVICE_NAME, "CentralNodeMonitorService" )
    );
    central_nms_url[1023]='\0';

    const char* defaultSubscriberURL = d_->cfg_->getString(NMS_DEFAULT_SUBSCRIBER_URL, central_nms_url );
    if( !strcmp( defaultSubscriberURL , d_->cfg_->getString(GS_MY_URL )))
    {
        //we are the central node. we dont subscribe to ourselves. 
    }
    else
    {
        if(defaultSubscriberURL != NULL && strlen(defaultSubscriberURL) > 0) 
        {
            Service::ServiceRef serviceRef;
            serviceRef.url=defaultSubscriberURL;
            serviceRef.serviceName=d_->cfg_->getString(NMS_DEFAULT_SUBSCRIBER_SERVICE_NAME);
            subscribePushConsumer(serviceRef, "*", "*");
        }

        // check if there is a default service to which this service
        // should subscribe
        // For instance, the secondary central NodeMonitorService will 
        // automatically subscribe to the primary central NodeMonitorService 
        if(const char* defaultSubscribeTargetURL = d_->cfg_->findString(GS_DEFAULT_SUBSCRIBE_TARGET_URL)) 
        {
            APPLOG_DBG("defaultSubscribeTargetURL=%s", defaultSubscribeTargetURL);
            
            CORBA::Object_ptr obj = SharedServiceMain::instance()->resolve(defaultSubscribeTargetURL);

            // Now downcast the object reference to the appropriate type
            Service::NodeMonitorService_var nodeMonitorService =
                Service::NodeMonitorService::_narrow (obj);
            APPLOG_DBG("back from _narrow");

            if (CORBA::is_nil (nodeMonitorService.in ()))
            {
                PANICV("ERROR: nodeMonitorService.in () object reference is_nil for %s", defaultSubscribeTargetURL);
                return; // not reached
            }

            nodeMonitorService->subscribePushConsumer(d_->myRef_, "*", "*");
        }
    }
}
  
// Implementation skeleton destructor
Service_NodeMonitorServiceImpl::~Service_NodeMonitorServiceImpl (void)
{
    delete d_;
}
  
void Service_NodeMonitorServiceImpl::registerService (
    const Service::ServiceRef & ref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        APPLOG_INFO("%s %s is registering on this service",
                    ref.serviceName.in(),
                    ref.url.in());

        const char_ptr pURL(ptr_strdup (ref.url) );
        MutexGuard mutexGuard(d_->lock_);
        
        int count=d_->pullFromRegistrantThreads_.count(pURL);
        if (count > 0)
        {
            APPLOG_INFO("%s %s is already registered on this service.  No action necessary", 
                        ref.serviceName.in(),
                        ref.url.in());
        }
        else
        {
            APPLOG_DBG("creating new PullFromRegistrantThread");

            Runnable* r=new PullFromRegistrantRunnable(ref, &(d_->serviceStatusMap_), d_->pullFromRegistrantThreadSleeptime_);
            RunnablePtr pRunnable(r);
        
            ThreadRunnable* threadRunnable=new ThreadRunnable(pRunnable);

            d_->pullFromRegistrantThreads_[pURL] = threadRunnable;
            threadRunnable->start();
        }
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "registerService() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "registerService() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
  }
  
void Service_NodeMonitorServiceImpl::unregisterService (
    const Service::ServiceRef & ref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        APPLOG_DBG("Service_NodeMonitorServiceImpl::unregisterService (%s)", ref.url.in());
        const char_ptr pURL(ptr_strdup (ref.url) );
        ThreadRunnablePtr pThreadRunnable =  d_->pullFromRegistrantThreads_[pURL];

        MutexGuard mutexGuard(d_->lock_);
        // now what do we do to end thread?
        APPLOG_DBG("before erase, map has size %d", d_->pullFromRegistrantThreads_.size());
        d_->pullFromRegistrantThreads_.erase(pURL);
        APPLOG_DBG(" after erase, map has size %d", d_->pullFromRegistrantThreads_.size());
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "unregisterService() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "unregisterService() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
  }
  
::Service::ServiceStatusList * Service_NodeMonitorServiceImpl::pullStatusList (
    const char * serviceName,
    const char * hostname
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        APPLOG_DBG("Service_NodeMonitorServiceImpl::pullStatusList (%s, %s)", serviceName, hostname);
        // the elements method blocks on the ServiceStatusMaps's mutex
        Service::ServiceStatusList* serviceStatusList = d_->serviceStatusMap_.elements(serviceName, hostname);
        APPLOG_DBG("serviceStatusList->length()=%d", serviceStatusList->length());

        return serviceStatusList;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "pullStatusList() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "pullStatusList() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}
  
void Service_NodeMonitorServiceImpl::subscribePushConsumer (
    const Service::ServiceRef& pushConsumer,
    const char * serviceName,
    const char * host
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    APPLOG_INFO("NodeMonitorPushConsumer %s is subscribing to this service for status on the following service: \"%s\" and host: \"%s\"",
                pushConsumer.url.in(),
                serviceName, host);

    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        char_ptr pURL(ptr_strdup (pushConsumer.url) );
        MutexGuard mutexGuard(d_->lock_);
        int count=d_->pushToSubscriberThreads_.count(pURL);
        if (count > 0)
        {
            APPLOG_INFO("NodeMonitorPushConsumer %s is already subscribed to this service.  No action necessary", pURL.get());
        }
        else
        {
            APPLOG_DBG("creating new PushToSubscriberThread");

            Runnable* r=new PushToSubscriberRunnable(pushConsumer, &(d_->serviceStatusMap_), d_->pushToSubscriberThreadSleeptime_, serviceName, host);
            RunnablePtr pRunnable(r);
        
            ThreadRunnable* threadRunnable=new ThreadRunnable(pRunnable);

            APPLOG_DBG("d_->pushToSubscriberThreads_[pURL] = threadRunnable");
            d_->pushToSubscriberThreads_[pURL] = threadRunnable;
            threadRunnable->start();
        }
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "subscribePushConsumer() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "subscribePushConsumer() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
  }
  
void Service_NodeMonitorServiceImpl::unsubscribePushConsumer (
    const Service::ServiceRef & pushConsumer
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        APPLOG_DBG("Service_NodeMonitorServiceImpl::unsubscribePushConsumer (%s)", pushConsumer.url.in());

        const char_ptr pURL(ptr_strdup (pushConsumer.url) );
        ThreadRunnablePtr pThreadRunnable = d_->pushToSubscriberThreads_[pURL];

        MutexGuard mutexGuard(d_->lock_);
        // now what do we do to end thread?
        APPLOG_DBG("before erase, map has size %d", d_->pushToSubscriberThreads_.size());
        d_->pushToSubscriberThreads_.erase(pURL);
        APPLOG_DBG(" after erase, map has size %d", d_->pushToSubscriberThreads_.size());
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "unsubscribePushConsumer() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "unsubscribePushConsumer() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
  }
  
void Service_NodeMonitorServiceImpl::ping (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        APPLOG_DBG("in ping");
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "ping() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "ping() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
  }
  
::Service::ServiceStatus * Service_NodeMonitorServiceImpl::pullStatus (
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
  ))
  {
    // Add your implementation here
    Service::ServiceException err;
    try
    {

        struct timeval tv;
        struct timezone tz;

        gettimeofday(&tv, &tz);

        APPLOG_DBG("Service_NodeMonitorServiceImpl::pullStatus()");
        Service::ServiceStatus* serviceStatus = new Service::ServiceStatus();
        serviceStatus->ref = d_->myRef_;
        //initializing the statusReceivedTime to the creation time
        //although this is expected to be overwritten on the receiving end.
        serviceStatus->statusReceivedTime= tv.tv_sec;
        serviceStatus->pid= d_->pid_;
        serviceStatus->isPendingShutdown=false;
        serviceStatus->live=true;

        // the following line is BAD, what what to do with this memory?
        // ServiceStatusPtr pServiceStatus = serviceStatus;
        APPLOG_DBG("Service_NodeMonitorServiceImpl::pullStatus returning:");
        d_->serviceStatusMap_.printServiceStatus(serviceStatus);
        return serviceStatus;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "pullStatus() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "pullStatus() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
}
  
void Service_NodeMonitorServiceImpl::reconfigure (
    const Service::NVPairList & configuration
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        Service::NVPairList c=configuration;
        PANIC("JobQueueServiceImpl::reconfigure not implemented yet");
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "reconfigure() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "reconfigure() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
  }
  
void Service_NodeMonitorServiceImpl::gracefulShutdown (
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        APPLOG_DBG("Service_NodeMonitorServiceImpl::gracefulShutdown ()");
        d_->isPendingShutdown_=true;
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "gracefulShutdown() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "gracefulShutdown() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
  }
  
void Service_NodeMonitorServiceImpl::pushStatusList (
    const Service::ServiceStatusList & serviceStatusList
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Service::ServiceException
    , Service::PendingShutdownException
  ))
  {
    // Add your implementation here
    if (d_->isPendingShutdown_)
    {
        throw Service::PendingShutdownException();
    }
    Service::ServiceException err;
    try
    {
        d_->serviceStatusMap_.pushStatusList(serviceStatusList);
        return;
    }
    catch( std::exception &e )
    {
        APPLOG_WARN( "pushStatusList() caught exception: %s", e.what());
        err.what_string = e.what();
    }
    catch( ... )
    {
        err.what_string = "pushStatusList() caught unknown exception";
        APPLOG_WARN( err.what_string );
    }
    throw err;
  }
  
